#![recursion_limit = "1024"]

extern crate syn;
#[macro_use]
extern crate quote;
extern crate proc_macro;

use proc_macro::TokenStream;
use syn::{Ident, Field, Ty, Lit, Generics, TyParam, Body, StrStyle, Attribute, Path, PathSegment, PathParameters, AngleBracketedParameterData, Visibility, MetaItem, NestedMetaItem, parse_path};

use std::mem::swap;
use std::fmt::Display;

/// Cretes builder for struct annotated with 'Builder' attribute.
#[proc_macro_derive(Builder, attributes(builder_name, builder_rename, builder_prefix, builder_validate))]
pub fn create_builder(input: TokenStream) -> TokenStream {
    let item = syn::parse_derive_input(&input.to_string()).unwrap();
    if let Body::Struct(s) = item.body {
        let builder = get_builder_name(&item.attrs);
        let (new, build) = get_builder_methods(&item.attrs);
        let prefix = get_setter_prefix(&item.attrs, Ident::new(""));

        // This module holds types generated so they don't conflict with user added/generated by other invocations of this.
        let builder_mod = Ident::new(format!("_{}", builder.to_string().to_lowercase()));
        let (validator, validator_error) = get_validator(&item.attrs, format!("{}::id", builder_mod));

        let name = &item.ident;
        let vis = &item.vis;
        let (impl_generics, ty_generics, _) = item.generics.split_for_impl();

        // Fields need to be renamed so that they don't conficlict with _marker field.
        let (opt_fields, fields): (Vec<_>, Vec<_>)
            = s.fields()
                .iter()
                .enumerate()
                .map(|(i, f)| (Ident::new(format!("_{}", i)), f))
                .partition(|&(_, ref f)| is_option(&f.ty));

        // Required fields are wrapped into option so that they can have value before set.
        // TODO: std::mem::uninitialized() should be able to be used for this
        let builder_fields: Vec<_> = fields.iter()
            .map(|&(ref i, ref f)| priv_field(i.clone(), wrap_into_option(f.ty.clone())))
            .collect();
        let builder_field_names: &Vec<_> = &builder_fields.iter()
            .map(|f| f.ident.clone())
            .collect();
        // Optional fields are already in optional!
        let builder_opt_fields: Vec<_> = opt_fields.iter()
            .map(|&(ref i, ref f)| priv_field(i.clone(), f.ty.clone()))
            .collect();
        let builder_opt_field_names: &Vec<_> = &builder_opt_fields.iter()
            .map(|f| f.ident.clone())
            .collect();
        let result_fields = fields.iter().map(|&(_, f)| &f.ident);
        let result_opt_fields = opt_fields.iter().map(|&(_, f)| &f.ident);

        // Unbound type parameters for builders required fields
        let builder_ty_params: &Vec<_> = &(0..builder_fields.len())
            .map(|i| plain_ty_param(format!("_T{}", i)))
            .collect();

        // All type parameters that the builder has.
        let mut ext_generics = item.generics.clone();
        add_ty_params(&mut ext_generics, builder_ty_params.clone());
        let (ext_impl_generics, ext_ty_generics, ext_where_clause) = ext_generics.split_for_impl();

        // Type parameters for constructor.
        // At the start builder doesn't have any values set.
        let mut start_generics = item.generics.clone();
        add_ty_params(&mut start_generics,
            (0..builder_fields.len())
                .map(|_| plain_ty_param(format!("{}::O", builder_mod))));
        let (_, start_ty_generics, start_where_clause) = start_generics.split_for_impl();

        // Type parameters for build method.
        // When building we require that every required value is set.
        let mut end_generics = item.generics.clone();
        add_ty_params(&mut end_generics,
            (0..builder_fields.len())
                .map(|_| plain_ty_param(format!("{}::I", builder_mod))));
        let (_, end_ty_generics, _) = end_generics.split_for_impl();

        let mut tks = quote!(
            #vis mod #builder_mod {
                pub struct O;
                pub struct I;
                #[allow(unused)]
                pub fn id<T>(t: T) -> T {t}
            }

            #[derive(Clone, Debug)]
            #vis struct #builder #ext_ty_generics #ext_where_clause {
                _marker: ::std::marker::PhantomData<(#(#builder_ty_params),*)>,
                #(#builder_fields,)*
                #(#builder_opt_fields),*
            }

            impl #impl_generics #builder #start_ty_generics #start_where_clause {
                #vis fn #new() -> #builder #start_ty_generics {
                    #builder {
                        _marker: ::std::marker::PhantomData,
                        #(#builder_field_names: None,)*
                        #(#builder_opt_field_names: None),*
                    }
                }
            }
        );

        let parsed: String = if let Some(error) = validator_error {
            quote!(
                impl #impl_generics #builder #end_ty_generics
                    #ext_where_clause
                {
                    #vis fn #build(self) -> Result<#name #ty_generics, #error> {
                        #validator(#name {
                            #(#result_fields: self.#builder_field_names.unwrap(),)*
                            #(#result_opt_fields: self.#builder_opt_field_names),*
                        })
                    }
                }
            ).parse().unwrap()
        } else {
            quote!(
                impl #impl_generics #builder #end_ty_generics
                    #ext_where_clause
                {
                    #vis fn #build(self) -> #name #ty_generics {
                        #validator(#name {
                            #(#result_fields: self.#builder_field_names.unwrap(),)*
                            #(#result_opt_fields: self.#builder_opt_field_names),*
                        })
                    }
                }
            ).parse().unwrap()
        };
        tks.append(&parsed);

        for (i, &(ref fname, ref field)) in opt_fields.iter().enumerate() {
            let mut builder_opt_field_names = builder_opt_field_names.clone();
            builder_opt_field_names.remove(i);
            let builder_opt_field_names = &builder_opt_field_names;

            // These are needed as workaround: quote doesn't allow binding variable twice in a loop.
            let builder_field_names2 = builder_field_names;
            let builder_opt_field_names2 = builder_opt_field_names;

            // This being optional field doesn't mean that the setter takes optional.
            let ty = unwrap_from_option(&field.ty).expect("Tried to get inner type from non-Option.");

            // Per field prefixes are supported
            let prefix = get_setter_prefix(&field.attrs, prefix.clone());
            let raw_name = field.ident.clone().unwrap_or_else(|| i.to_string().into());
            let name = Ident::new(&format!("{}{}", prefix, raw_name)[..]);

            let parsed: String = quote!(
                impl #ext_impl_generics #builder #ext_ty_generics #ext_where_clause {
                    #vis fn #name(self, #raw_name: #ty) -> #builder #ext_ty_generics {
                        #builder {
                            _marker: ::std::marker::PhantomData,
                            #fname: Some(#raw_name),
                            #(#builder_field_names: self.#builder_field_names2,)*
                            #(#builder_opt_field_names: self.#builder_opt_field_names2),*
                        }
                    }
                }
            ).parse().unwrap();
            tks.append(&parsed);
        }
        for (i, &(ref fname, ref field)) in fields.iter().enumerate() {
            let mut builder_field_names = builder_field_names.clone();
            builder_field_names.remove(i);
            let builder_field_names = &builder_field_names;

            // These are needed as workaround: quote doesn't allow binding variable twice in a loop.
            let builder_field_names2 = builder_field_names;
            let builder_opt_field_names2 = builder_opt_field_names;

            let ty = &field.ty;

            // Per field prefixes are supported
            let prefix = get_setter_prefix(&field.attrs, prefix.clone());
            let raw_name = field.ident.clone().unwrap_or_else(|| i.to_string().into());
            let name = Ident::new(&format!("{}{}", prefix, raw_name)[..]);

            // Because one concrete type parameter is used, all but one unbound one is needed.
            let mut other_generics = item.generics.clone();
            add_ty_params(&mut other_generics, builder_ty_params
                .iter().enumerate()
                .filter_map(|(j, t)| if i == j {
                    None
                } else {
                    Some(t.clone())
                }));
            let (other_impl_generics, _, _) = other_generics.split_for_impl();

            let change_index = |(j, mut t): (_, TyParam), ident: String| {
                if i == j { t.ident = ident.into(); }
                t
            };

            // Fields can be set only once, so we require that field wasn't set before.
            let mut set_generics = item.generics.clone();
            add_ty_params(&mut set_generics, builder_ty_params.clone()
                .into_iter().enumerate()
                .map(|n| change_index(n, format!("{}::O", builder_mod))));
            let (_, set_ty_generics, _) = set_generics.split_for_impl();

            // After setting field, type parameter is changed to indicate that.
            let mut after_set_generics = item.generics.clone();
            add_ty_params(&mut after_set_generics, builder_ty_params.clone()
                .into_iter().enumerate()
                .map(|n| change_index(n, format!("{}::I", builder_mod))));
            let (_, after_set_ty_generics, _) = after_set_generics.split_for_impl();

            let parsed: String = quote!(
                impl #other_impl_generics #builder #set_ty_generics #ext_where_clause {
                    #vis fn #name(self, #raw_name: #ty) -> #builder #after_set_ty_generics {
                        #builder {
                            _marker: ::std::marker::PhantomData,
                            #fname: Some(#raw_name),
                            #(#builder_field_names: self.#builder_field_names2,)*
                            #(#builder_opt_field_names: self.#builder_opt_field_names2),*
                        }
                    }
                }
            ).parse().unwrap();
            tks.append(&parsed);
        }
        debug_display(tks.parse().unwrap())
    } else {
        panic!("Only structs supported.");
    }
}

#[cfg(test)]
#[inline(always)]
fn debug_display<T: Display>(t: T) -> T {
    //TODO: Figure out how to make this apply for inregration tests.
    println!("{}", t);
    t
}

#[cfg(not(test))]
#[inline(always)]
fn debug_display<T: Display>(t: T) -> T {
    t
}

/// Returns inner type T of Option<T> or None if type wasn't Option.
fn unwrap_from_option(ty: &Ty) -> Option<&Ty> {
    if let &Ty::Path(_, Path{ref segments, ..}) = ty {
        let &PathSegment{ref ident, ref parameters} = &segments[0];
        if ident == "Option" {
            if let &PathParameters::AngleBracketed(ref a) = parameters {
                return a.types.get(0)
            }
        }
    }
    None
}

/// Wraps type T into Option<T>
fn wrap_into_option(ty: Ty) -> Ty {
    let mut params = AngleBracketedParameterData::default();
    params.types.push(ty);
    Ty::Path(None, PathSegment {
            ident: Ident::new("Option"),
            parameters: PathParameters::AngleBracketed(params),
        }.into())
}

/// Checks if give type is Option
fn is_option(ty: &Ty) -> bool {
    if let &Ty::Path(_, ref p) = ty {
        if let Some(s) = p.segments.get(0) {
            return s.ident == "Option";
        }
    }
    false
}

/// Collects iterators next element and panics with message if there is still elements left after that.
fn collect_most_one<I, T>(mut iter: I, message: &'static str) -> Option<T>
    where I: Iterator<Item=T>
{
    let result = iter.next();
    assert!(iter.fuse().next().is_none(), message);
    result
}

/// Gets builders constructor and build method names based on attribute and falls back to default ones if no attribute present.
fn get_builder_methods(attrs: &[Attribute]) -> (Ident, Ident) {
    let mut iter = attrs.iter()
        .filter_map(|a| {
            if let MetaItem::List(ref name, ref value) = a.value {
                if name == "builder_rename" {
                    return Some(value);
                }
            }
            None
        });
    collect_most_one(&mut iter, "Only one #[builder_rename] attribute supported for struct.")
        .unwrap_or(&vec![])
        .iter()
        .filter_map(|v| {
            if let &NestedMetaItem::MetaItem(MetaItem::NameValue(ref name, ref value)) = v {
                if name == "new" || name == "build" {
                    if let &Lit::Str(ref value, StrStyle::Cooked) = value {
                        return Some((name == "new", Ident::new(&value[..])));
                    }
                }
            }
            None
        })
        .fold((Ident::new("new"), Ident::new("build")), |(new, build), (first, v)| {
            if first {
                (v, build)
            } else {
                (new, v)
            }
        })
}

/// Gets builder structs name based on attribute and falls back to default one if no attribute present.
fn get_builder_name(attrs: &[Attribute]) -> Ident  {
    let mut iter = attrs.iter()
        .filter_map(|a| {
            if let MetaItem::NameValue(ref name, ref value) = a.value {
                if name == "builder_name" {
                    if let &Lit::Str(ref value, StrStyle::Cooked) = value {
                        return Some(Ident::new(&value[..]));
                    }
                }
            }
            None
        });
    collect_most_one(&mut iter, "Only one #[builder_name] attribute supported for struct.")
        .unwrap_or(Ident::new("Builder"))
}

/// Gets setter prefix based on attribute and falls back to default given as parameter if no attribute present.
fn get_setter_prefix(attrs: &[Attribute], default: Ident) -> Ident {
    let mut iter = attrs.iter()
        .filter_map(|a| {
            if let MetaItem::NameValue(ref name, ref value) = a.value {
                if name == "builder_prefix" {
                    if let &Lit::Str(ref value, StrStyle::Cooked) = value {
                        return Some(Ident::new(&value[..]));
                    }
                }
            }
            None
        });
    collect_most_one(&mut iter, "Only one #[builder_prefix] attribute supported per item.")
        .unwrap_or(default)
}

/// Gets validator function and error type based on attribute and falls back to default if there isn't one.
fn get_validator<P: Into<Path>>(attrs: &[Attribute], default: P) -> (Path, Option<Path>) {
    let mut iter = attrs.iter()
        .filter_map(|a| {
            if let MetaItem::List(ref name, ref value) = a.value {
                if name == "builder_validate" {
                    return Some(value);
                }
            }
            None
        });
    let result = collect_most_one(&mut iter, "Only one #[builder_validate] attribute supported for struct.");
    if let Some(r) = result {
        let (v, e) = r.iter()
        .filter_map(|v| {
            if let &NestedMetaItem::MetaItem(MetaItem::NameValue(ref name, ref value)) = v {
                if name == "validator" || name == "error" {
                    if let &Lit::Str(ref value, StrStyle::Cooked) = value {
                        return Some((name == "validator", parse_path(&value[..]).expect("Malformed path given to `builder_validate` attribute")));
                    }
                }
            }
            None
        })
        .fold((None, None), |(validator, error), (first, v)| {
            if first {
                (Some(v), error)
            } else {
                (validator, Some(v))
            }
        });
        (v.expect("Validator function has to be provided for `builder_validate` attribute."), e)
    } else {
        (default.into(), None)
    }
}


/// Constructs type parameter without bounds from identifier.
fn plain_ty_param<I: Into<Ident>>(ident: I) -> TyParam {
    TyParam {
        ident: ident.into(),
        attrs: vec![],
        bounds: vec![],
        default: None,
    }
}

/// Constructs private field from identifier and type.
fn priv_field<I: Into<Ident>>(ident: I, ty: Ty) -> Field {
    Field {
        ident: Some(ident.into()),
        vis: Visibility::Inherited,
        attrs: vec![],
        ty: ty,
    }
}

/// Adds type parameters to the start of generics.
fn add_ty_params<I: IntoIterator<Item=TyParam>>(generics: &mut Generics, ty_params: I) {
    let mut empty = vec![];
    swap(&mut empty, &mut generics.ty_params);
    generics.ty_params = ty_params.into_iter()
        .chain(empty)
        .collect();
}
